<html>
<head>
    <title>Pop Navigation</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="../../css/prism.css">
    <link rel="stylesheet" href="../../css/navigation.css">
    <style>
        :root {
          --primary-color: #9cc3d5ff;
          --secondary-color: #0063b2ff;
        }    
      </style>
  </head>
  <body>
      <div id="banner">
        <a href="../../native"><img alt="logo" src="../../img/logo.png" /></a>
        <a href="../setup.html">React</a>
        <a href="https://github.com/grahammendick/navigation">GitHub</a>
      </div>
      <div id="content">
          <div id="menu">
              <h2>
                  <img alt="native" src="../../img/native.png" />
                  React Native
              </h2>
              <div id="items">
                  <a href="setup.html">Setup</a>
                  <a href="hello-world.html">Hello World</a>
                  <a href="push-navigation.html">Push Navigation</a>
                  <a href="pop-navigation.html" class="selected">Pop Navigation</a>
                  <a href="navigation-bar.html">Navigation Bar</a>
                  <a href="tab-bar.html">Tab Bar</a>
                  <a href="modal.html">Modal</a>
                  <a href="drawer.html">Drawer</a>
                  <a href="scene-navigation-lifecycle.html">Navigation Lifecycle</a>
                  <a href="custom-animation.html">Custom Animation (Android)</a>
                  <a href="shared-element-transition.html">Shared Element Transition (Android)</a>
                  <a href="deep-links.html">Deep Links</a>
                  <a href="typescript.html">TypeScript</a>
                  <a href="examples.html">Examples</a>
              </div>
          </div>
          <div id="article">
            <h1>Pop Navigation</h1>
            <h2>Popping</h2>
            <p>
                Because the Navigation router pushes scenes using the native APIs, the user can pop them via the Android back button or swiping/pressing back on iOS. You can also programmatically pop scenes by calling the <code>navigateBack</code> function on the <code>StateNavigator</code>. The number you pass in indicates the number of scenes to pop. In our email example, we can add a button to the 'compose' scene that returns the user to the inbox.
            </p>
            <pre><code class="language-jsx">import {NavigationContext} from 'navigation-react';

const Compose = () => {
  const {stateNavigator} = useContext(NavigationContext);
  return (
    &lt;TouchableHighlight
      onPress={() => {
        stateNavigator.navigateBack(1);
      }}>
      &lt;Text>Back to Inbox&lt;/Text>
    &lt;/TouchableHighlight>
  );
};</code></pre>
            <h2>Popping to Top</h2>
            <p>
                The Navigation router is the only React Native router that navigates natively on Android and iOS where you can interrogate the stack in JavaScript. You recall that the Navigation router drops a breadcrumb at each visited scene, just like the fairy-tale characters Hansel and Gretel. The stack of visited scenes is represented in JavaScript as an array of breadcrumbs. Each crumb corresponds to a visited scene and holds the <code>State</code> and navigation data associated with it.
            </p>
            <p>
                Let's use this array of crumbs to make the 'Back to Inbox' button work regardless of the route the user takes to get to the 'compose' scene. For example, if the user presses the 'Compose Mail' button after opening an email, then popping one scene off the stack goes back to the open email instead of the inbox. We ensure the 'Back to Inbox' button always pops to the top of the stack by navigating back the length of the <code>crumbs</code> array.
            </p>
            <pre><code class="language-jsx">const {crumbs} = stateNavigator.stateContext;
stateNavigator.navigateBack(crumbs.length);</code></pre>
            <h2>Popping when Pushing</h2>
            <p>
                By default, each navigation adds one to the size of the stack. You can change this behaviour by attaching a <code>truncateCrumbTrail</code> function to a <code>State</code>. During a navigation, the Navigation router calls this function on the destination <code>State</code>. It passes in the provisional stack, as an array of <code>crumbs</code>, and you return the modified stack. Removing a crumb from the array pops the corresponding scene from the stack.
            </p>
            <p>
                In our example, we can add an 'Expand' button to the 'mail' scene so the user can view the full email conversation. On click, we navigate to the 'mail' scene again and pass an 'expand' boolean in navigation data. We must pop the scene showing the collapsed email from the stack so that navigating back still returns the user to their inbox. Put another way, we must prevent consecutive occurrences of the mail <code>State</code> appearing in the <code>crumbs</code> array.
            </p>
            <pre><code class="language-jsx">const {mail} = stateNavigator.states;
mail.truncateCrumbTrail = (state, data, crumbs) => {
  const latestCrumb = crumbs[crumbs.length - 1];
  return latestCrumb.state === state ? crumbs.slice(0, -1) : crumbs;
};</code></pre>
        </div>
    </div>
    <script type="text/javascript" src="../../js/prism.js"></script>
</body>
</html>